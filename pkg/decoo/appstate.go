package decoo

import (
	"crypto/ed25519"
	"encoding/hex"
	"encoding/json"
	"sync"

	"github.com/iotaledger/inx-tendercoo/pkg/decoo/proto/tendermint"
	iotago "github.com/iotaledger/iota.go/v3"
	"golang.org/x/crypto/blake2b"
)

// Key32 is a 32-byte array type that can be used as a map key for JSON marshaling.
type Key32 [32]byte

// MarshalText encodes the receiver into UTF-8-encoded text and returns the result.
func (k Key32) MarshalText() ([]byte, error) {
	dst := make([]byte, hex.EncodedLen(32))
	hex.Encode(dst, k[:])
	return dst, nil
}

// UnmarshalText must be able to decode the form generated by MarshalText.
func (k *Key32) UnmarshalText(text []byte) error {
	_, err := hex.Decode(k[:], text)
	return err
}

func (k Key32) String() string {
	return hex.EncodeToString(k[:])
}

// Key32FromBytes creates a Key32 from a byte slice.
func Key32FromBytes(b []byte) (key Key32) {
	if len(b) != 32 {
		panic("invalid byte slice length")
	}
	copy(key[:], b)
	return key
}

// AppState holds the global application state.
type AppState struct {
	sync.RWMutex

	State

	// Timestamp denotes the time of the last block header.
	Timestamp uint32

	// ParentByIssuer contains the proposed parent IDs sorted by the proposers PublicKey.
	ParentByIssuer map[Key32]iotago.BlockID
	// IssuerCountByParent counts the issuers of each parent
	IssuerCountByParent map[Key32]int

	// ProofsByMsgID contains the received proofs sorted by Proof.PreMilestoneMsgID and Proof.PublicKey.
	ProofsByMsgID map[Key32]map[Key32]struct{}

	// Milestone contains the constructed Milestone, or nil if we are still collecting proofs.
	Milestone *iotago.Milestone
	// SignaturesByIssuer contains the received Signature sorted by Signature.PublicKey.
	SignaturesByIssuer map[Key32]*iotago.Ed25519Signature
}

// MarshalBinary provides deterministic marshalling of the state.
func (a *AppState) MarshalBinary() ([]byte, error) { return json.Marshal(a) }

// UnmarshalBinary must be able to decode the form generated by MarshalBinary.
func (a *AppState) UnmarshalBinary(data []byte) error { return json.Unmarshal(data, a) }

// Reset resets the complete state after a new milestone has been issued.
func (a *AppState) Reset(state State) {
	a.State = state
	a.Timestamp = 0
	a.ParentByIssuer = map[Key32]iotago.BlockID{}
	a.IssuerCountByParent = map[Key32]int{}
	a.ProofsByMsgID = map[Key32]map[Key32]struct{}{}
	a.Milestone = nil
	a.SignaturesByIssuer = map[Key32]*iotago.Ed25519Signature{}
}

func (a *AppState) MilestoneID() iotago.MilestoneID {
	id, err := a.Milestone.ID()
	if err != nil {
		panic(err)
	}
	return id
}

// Hash returns the BLAKE2b-256 hash of the state.
func (a *AppState) Hash() []byte {
	hash := blake2b.Sum256(mustMarshal(a))
	return hash[:]
}

// CheckParent performs syntactic validation on a Proof.
func (a *AppState) CheckParent(p *tendermint.Parent) uint32 {
	if p == nil {
		return CodeTypeSyntaxError
	}
	// index must not be in the past
	if p.Index < a.CurrentMilestoneIndex {
		return CodeTypeStateError
	}
	// the milestone MsgID must have the correct length
	if len(p.MessageId) != len(iotago.BlockID{}) {
		return CodeTypeSyntaxError
	}
	return CodeTypeOK
}

// DeliverParent performs semantic validation on a Proof and updates the state accordingly.
func (a *AppState) DeliverParent(issuer ed25519.PublicKey, p *tendermint.Parent, _ *Committee) uint32 {
	// proof must match the current milestone index
	if p.Index != a.CurrentMilestoneIndex {
		return CodeTypeStateError
	}
	// proofs are only relevant before we created a milestone
	if a.Milestone != nil {
		return CodeTypeStateError
	}
	// there must be at most one parent per issuer
	issuerKey := Key32FromBytes(issuer)
	if _, has := a.ParentByIssuer[issuerKey]; has {
		return CodeTypeReplayError
	}

	// add the parent to the state
	msgID := Key32FromBytes(p.GetMessageId())
	a.ParentByIssuer[issuerKey] = iotago.BlockID(msgID)
	a.IssuerCountByParent[msgID]++
	return CodeTypeOK
}

// CheckProof performs syntactic validation on a Proof.
func (a *AppState) CheckProof(p *tendermint.Proof) uint32 {
	if p == nil {
		return CodeTypeSyntaxError
	}
	// index must not be in the past
	if p.Index < a.CurrentMilestoneIndex {
		return CodeTypeStateError
	}
	// the milestone MsgID must have the correct length
	if len(p.ParentId) != len(iotago.BlockID{}) {
		return CodeTypeSyntaxError
	}
	return CodeTypeOK
}

// DeliverProof performs semantic validation on a Proof and updates the state accordingly.
func (a *AppState) DeliverProof(issuer ed25519.PublicKey, p *tendermint.Proof, _ *Committee) uint32 {
	// proof must match the current milestone index
	if p.Index != a.CurrentMilestoneIndex {
		return CodeTypeStateError
	}
	// proofs are only relevant before we created a milestone
	if a.Milestone != nil {
		return CodeTypeStateError
	}
	// the referenced message must be a parent
	msgID := Key32FromBytes(p.ParentId)
	if a.IssuerCountByParent[msgID] < 1 {
		return CodeTypeStateError
	}
	// check that the same proof was not issued already
	proofs := a.ProofsByMsgID[msgID]
	if proofs == nil {
		proofs = map[Key32]struct{}{}
		a.ProofsByMsgID[msgID] = proofs
	}
	if _, has := proofs[Key32FromBytes(issuer)]; has {
		return CodeTypeReplayError
	}

	// add the proof to the state
	proofs[Key32FromBytes(issuer)] = struct{}{}
	return CodeTypeOK
}

// CheckPartial performs syntactic validation on a PartialSignature.
func (a *AppState) CheckPartial(p *tendermint.PartialSignature) uint32 {
	if p == nil {
		return CodeTypeSyntaxError
	}
	// index must not be in the past
	if p.Index < a.CurrentMilestoneIndex {
		return CodeTypeStateError
	}
	// the MilestoneSignature must have the correct length
	if len(p.MilestoneSignature) != ed25519.SignatureSize {
		return CodeTypeSyntaxError
	}
	return CodeTypeOK
}

// DeliverPartial performs semantic validation on a PartialSignature and updates the state accordingly.
func (a *AppState) DeliverPartial(issuer ed25519.PublicKey, p *tendermint.PartialSignature, committee *Committee) uint32 {
	// signature must match the current milestone index
	if p.Index != a.CurrentMilestoneIndex {
		return CodeTypeStateError
	}
	// there must be a milestone essence to sign
	if a.Milestone == nil {
		return CodeTypeStateError
	}
	// there must be at most one signature per issuer
	if _, has := a.SignaturesByIssuer[Key32FromBytes(issuer)]; has {
		return CodeTypeReplayError
	}
	// the signature must be valid
	essence, err := a.Milestone.Essence()
	if err != nil {
		panic(err)
	}
	if err := committee.VerifySingle(essence, issuer, p.MilestoneSignature); err != nil {
		return CodeTypeSyntaxError
	}

	sig := &iotago.Ed25519Signature{}
	copy(sig.PublicKey[:], issuer)
	copy(sig.Signature[:], p.MilestoneSignature)

	// add the partial signature to the state
	a.SignaturesByIssuer[Key32FromBytes(issuer)] = sig
	return CodeTypeOK
}
